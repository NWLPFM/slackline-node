// server.js

// Node.js implementation of slackline â€“ https://github.com/ernesto-jimenez/slackline


// BASE SETUP
// ========================================================================================

// required modules
var settings  = require('./settings.json');
var raven = require('raven');
var express   = require('express');
var bodyParser  = require('body-parser');
var http    = require('http');
var https   = require('https');
var querystring = require('querystring');
var request   = require('request');
var url       = require('url');
var fs = require('fs');
var path = require('path');
var exphbs = require('express-handlebars');

// create an instance of express
var app = express();

// Catch errors
app.use(raven.middleware.express.requestHandler(settings.sentryDSN));
app.use(raven.middleware.express.errorHandler(settings.sentryDSN));

// Configure the templating engine
app.engine('handlebars', exphbs({defaultLayout: 'main'}));
app.set('views', path.resolve(__dirname, 'views'));
app.set('view engine', 'handlebars');
app.use(express.static(path.resolve(__dirname, 'static')));

// configure the app to use bodyParser()
// this will allow us to interpret the data from a POST
app.use(bodyParser.urlencoded({ extended: true }));
app.use(bodyParser.json());

var port = process.env.PORT || 8080;


// ROUTES
// ========================================================================================

var router = express.Router();

router.get('/', function(req, res) {
  res.json({ message: "hooray! welcome to slackline!0 "});
});

router.get('/setup', function(req, res) {
  var urlbase = settings.uribase || url.format({
    protocol: req.protocol,
    host: req.hostname,
    port: port
  });
  res.render('index', {settings: settings, urlbase: urlbase, slackdomain: "www"});
});

router.get('/reload', function(req, res) {
  try {
    settings = JSON.parse(fs.readFileSync(path.resolve(__dirname, 'settings.json'), 'utf-8'));
    res.json({success: true});
  } catch(e) {
    res.status(500).json({success: false, stack: e.stack});
  }
});

router.all('/bridge', function(req, res) {
  var username = req.body.user_name;
  var userid = req.body.user_id;
  var source = req.body.team_domain;
  var channel = req.query.channel || req.body.channel_name;
  var text = req.body.text;

  // to avoid infinite loops, don't post messages generated by slackbot
  if (username == "slackbot") {
    res.end('Message forwarded!');
    return;
  } else if(checkToken(req.body)) {
    getIcon(userid, source, function(err, icon_url) {
      fixMentions(text, source, function(err, cleanText) {
        // sendToAll(icon_url, username, cleanText, source_domain);
        sendToAll(icon_url, username, cleanText, channel, source);
      });
    });

    // TO DO: only fire success message when sendPost actually finishes (via a callback)
    res.end('Message forwarded!');
  } else {
    res.status(400).json({ success: false, message: "Improper request body sent!"});
  }
});

app.use(router);

// START THE SERVER
// ========================================================================================

app.listen(port);
console.log('slackline is running on port ' + port);


// FUNCTIONS
// ========================================================================================


var mentionMap = {};

// takes a raw Slack message as an input, returns a cleaned string with any @ mentions converted to the relevant usernames
function fixMentions(text, source, next){
  var strText = text;
  var userPattern = /<@([^>]+)>/igm;
  var userArray = strText.match(userPattern);

  if (userArray) {
    var counter = 0;

    userArray.forEach(function(strUseridRaw){
      if (mentionMap[strUseridRaw]) {
        strText = strText.replace(strUseridRaw, '@' + mentionMap[strUseridRaw]);
        counter += 1;
        if (counter == (userArray.length)) {
          next(null, strText);
        }
      } else {
        var strUserid = strUseridRaw.substring(2, strUseridRaw.length -1);

        // use the sender's domain and userid to grab their user info from the Slack API
        var url = 'https://slack.com/api/users.info?token=' + settings.domains[source].key + '&user=' + strUserid;

        https.get(url, function(res) {
          var body = '';

          res.on('data', function(chunk) {
            body += chunk;
          });

          res.on('end', function() {
            var userResponse = JSON.parse(body);
            var username = userResponse.user.name;
            mentionMap[strUseridRaw] = username;
            strText = strText.replace(strUseridRaw, '@' + username);
            counter += 1;
            if (counter == (userArray.length)) {
              next(null, strText);
            }
          });
        }).on('error', function(e) {
          console.log('Got error: ' + e);
        });
      }
    });
  } else {
    next(null, text);
  }
}


// cache of hashed email addresses, used for Gravatar URLs
var icon_map = {};

function getIcon(userid, source, next) {

  if (icon_map[userid]) {
    var icon_url = icon_map[userid];
    next(null, icon_url);
  } else {
    // use the sender's domain and userid to grab their user info from the Slack API
    var apiurl = 'https://slack.com/api/users.info?token=' + settings.domains[source].key + '&user=' + userid;

    https.get(apiurl, function(res) {
      var body = '';

      res.on('data', function(chunk) {
        body += chunk;
      });

      res.on('end', function() {
        var userResponse = JSON.parse(body);
        var icon_url = userResponse.user.profile.image_192;
        icon_map[userid] = icon_url;
        next(null, icon_url);
      });
    }).on('error', function(e) {
      console.log('Got error: ' + e);
    });
  }
}

function sendToAll(icon_url, username, text, channel, source) {
  for(var domain in settings.domains) {
    if(settings.domains.hasOwnProperty(domain) && settings.domains[domain].webhook && domain != source) {
      var target_channel = channel;
      if(settings.channel_map && settings.channel_map[channel] && settings.channel_map[channel][domain]) {
        target_channel = settings.channel_map[channel][domain];
      }
      sendPost(icon_url, username, text, target_channel, settings.domains[domain].webhook);
    }
  }
}


// Send the forwarded message as a POST to the target Slack instance
function sendPost(icon_url, username, text, channel, target) {
  var options = {
    uri: target,
    method: 'POST',
    json: true,
    body: {
      'channel': "#" + channel,
      'username': username,
      'text': text,
      'icon_url': icon_url
    }
  };

  request(options, function(error, response, body) {
    if(error) {
      console.log("Error posting message to channel", channel, "on", target, "Error stack:\n", error.stack);
    } else if(response.statusCode != 200) {
      console.log("Bad response from Slack when attempting to post to channel", channel, "on", target,  body);
    }
  });
}

function checkToken(requestbody) {
  if(!requestbody) {
    console.log("Received empty request body. Probably not from Slack (or they changed their APIs significantly)");
    return false;
  }
  var domain = requestbody.team_domain;
  var channel = requestbody.channel_name;
  var token = requestbody.token;
  if(!domain || !channel || !token) {
    console.log("Request does not have channel, domain and/or token in the body. Maybe Slack changed up their APIs? Here's the full request body:", requestbody);
    console.log("Hint: You should probably update slackline-node, or if you are up to date, file an issue");
    return false;
  }
  if(!settings.domains) {
    console.log("settings.domains not set! Please configure slackline before using it!");
    return false;
  }
  if(!settings.domains[domain]) {
    console.log("Received a request for domain", domain, "but settings.domains has no item with that key!");
    return false;
  }
  if(!settings.domains[domain].tokens) {
    console.log("No tokens configured for domain", domain, ", cannot validate message");
    return false;
  }
  if(!settings.domains[domain].tokens[channel]) {
    console.log("No tokens configured for channel", channel, "on domain", domain, ", cannot validate message!");
    return false;
  }
  if(settings.domains[domain].tokens[channel] == token) {
    return true;
  } else {
    console.log("Received incorrect token for message from channel", channel, "on domain", domain, ", refusing to pass message on!");
    return false;
  }
}
